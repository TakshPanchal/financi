const fs = require('fs')
const dotenv = require('dotenv')
const express = require("express")
const app = express()
app.use(express.json())
dotenv.config()
const Pool = require('pg').Pool

// const ca_cert = process.env.SSL_CERT_CONTENTS ? process.env.SSL_CERT_CONTENTS : fs.readFileSync(process.env.SSL_CERT)
// host: process.env.DB_HOST,
//   database: process.env.DB_DBNAME,
//   user: process.env.DB_USERNAME,
//   password: process.env.DB_PASSWORD,
//   port: process.env.DB_PORT

const pool = new Pool({
  connectionString: process.env.DATABASEURL
})
//create a customer(user)
const createCustomer = (req, res)  => {
    
    console.log(req.body)
    const {uid, user_name, email} = req.body
    //use RETURNING to return uuid generated by CRDB
    pool.query('INSERT INTO users (user_name, email, uid) VALUES ($1, $2, $3)',
     [user_name, email, uid], (error, results) => {
        if (error) {
            res.status(404).send('The user with the given ID was not found.')
            throw error
        }
        res.status(200).json(results.rows[0])
    })
}

//check if the particular user exists or not by checking their uid
const getCustomerById = (req, res) => {
    const id = req.params.id
    pool.query('SELECT * FROM user WHERE uid = $1;',
        [id], (error, results) => {
        if (error) {
            res.status(404).send('The user with the given ID was not found.')
            throw error
        }
        res.status(200).json(results.rows)
    })
}

//create a Transaction
//raft write
const createTransaction = (req, res)  => {
    const {user_id, merchant_name, amount, closing_balance, tag_id, type, date, description, reference_number} = req.body
    //use RETURNING to return uuid generated by CRDB
    // type of transaction refers to Credit/Debit, 1 -> Credit, 0->Debit
    pool.query('INSERT INTO transactions (user_id, merchant_name, amount, closing_balance, tag_id, type, date, description, reference_number) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)',
     [user_id, merchant_name, amount, closing_balance, tag_id, type, date, description, reference_number], (error, results) => {
        if (error) {
            res.status(404).send('The transaction with the given Merchant and on the particular date was not found.')
            throw error
        }
        console.log(results)
        res.status(200).json(results.rows[0])
    })
}

// get all transactions of a user i.e uid is provided
const getTransactionById = (req, res) => {
    const id = req.params.id
    pool.query('SELECT t.date, t.merchant_name, t.amount, t.closing_balance, t.tag_id, t.type, t.reference_number FROM users u JOIN transactions t ON u.user_id = t.user_id WHERE u.uid=$1',
        [id], (error, results) => {
        if (error) {
            res.status(404).send('The transactions for the given user does not exist')
            throw error
        }
        res.status(200).json(results.rows)
    })
}


// get all the public tags from Tags table where tag_type = 1 (Public), 0 (Private)
const getAllPublicTags = (req, res) => {
    try{
        pool.query('SELECT * FROM Tags WHERE tag_type=True', 
        (error, results) => {
            if (error) {
                res.status(404).send('Seems like there aren\'t any public tags yet.'+error)
                //throw error
                console.log(error);
                return;
            }
            res.status(200).json(results.rows)
        })
    }
    catch(e){
        console.log(e);
    }
}

// get tags of a user whose uid is provided
const getAllTagsUser = (req, res) => {
    const {uid} = req.params.uid
    pool.query('SELECT g.tag_name FROM users u JOIN transactions t ON u.user_id = t.user_id JOIN tags g ON t.tags = g.tag_id WHERE u.uid = $1 ',
        [uid], (error, results) => {
        if (error) {
            res.status(404).send('The customer with the given ID was not found.')
            throw error
        }
        res.status(200).json(results.rows)
    })
}


// create new tag
const createPrivateTag = (req, res) => {
    const {tag_name} = req.body
    const tag_type = False //False implies private
    pool.query('INSERT INTO tags (tag_name, tag_type) VALUES ($1, $2) \
        RETURNING tag_id;',
     [tag_name, tag_type], (error, results) => {
        if (error) {
            res.status(404).send('The tag with the given ID was not found.')
            throw error
        }
        res.status(200).json(results.rows[0])
     })

}


module.exports = {
    createCustomer,
    getCustomerById,
    createTransaction,
    getAllPublicTags,
    getAllTagsUser,
    createPrivateTag,
    getTransactionById,
  }